pragma solidity 0.7.4;
pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";
import "../../interfaces/ICErc20.sol";
import "../../interfaces/IVault.sol";
import "../../interfaces/ILendingPool.sol";
import "../../interfaces/IPolyVaultRegistry.sol";
import {LaunchLogger} from "../launch/LaunchLogger.sol";
import "../system/PolylaunchConstants.sol";

/**
 * @title PolyVault associated with a particular Polylaunch contract,
 *        logic for interacting with interest bearing protocols is handled here.
 * @author Polylaunch Protocol
 */

contract PolyVault{
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    // the id of the current vault selected by the launcher
    // (refer to VaultRegistry to view the information for the vault id)
    uint256 public selectedVaultId;

    // the id of the current vault provider selected by the launcher
    uint256 public selectedVaultProvider;

    // whether the vault has been activated by the launcher
    bool public activated;

    // the last time the launcher tapped from the vault.
    uint256 public lastWithdrawn;

    // the remaining balance in USD available to the launcher
    uint256 public remainingBalance;

    /**
     * @notice modifier to check that configured launch is making a call
     */
    modifier onlySelf() {
        require(
            msg.sender == address(this),
            "Caller must be Launch"
        );
        _;
    }
    /**
     * @notice deposit function to place funds into a vault/pool
     * @param _vaultRegistry the address of the registry that the PolyVault will get information from
     * @param _vaultId the unique identifier of the vault the launcher would like to deposit funds to
     * @param _startingBalance the balance being deposited into the PolyVault
     * @param _USD the IERC20 interface of the stablecoin being used
     * @dev only callable from the launch contract
     */
    function _deposit(
        address _vaultRegistry,
        uint256 _vaultId,
        uint256 _startingBalance,
        IERC20 _USD,
        address _system
    ) external onlySelf {
        IPolyVaultRegistry vaultRegistry = IPolyVaultRegistry(_vaultRegistry);
        IPolyVaultRegistry.Vault memory selectedVault =
            vaultRegistry.getRegisteredVault(_vaultId);
        require(
            selectedVault.vaultActive,
            "Vault: The selected vaultId is inactive"
        );
        uint256 _vaultProvider = selectedVault.vaultProvider;
        if (_vaultProvider == 1) {
            _activateCompound(_USD, _startingBalance, selectedVault);
        } else if (_vaultProvider == 2) {
            _activateYearnVault(_USD, _startingBalance, selectedVault);
        } else if (_vaultProvider == 3) {
            _activateAave(_USD, _startingBalance, selectedVault);
        }
        selectedVaultId = _vaultId;
        selectedVaultProvider = _vaultProvider;
        remainingBalance = _startingBalance;
        lastWithdrawn = block.timestamp;
        activated = true;
        LaunchLogger(_system).logVaultFundsDeposited(
            address(this),
            _startingBalance,
            _vaultProvider,
            _vaultId
        );
    }

    /**
     * @notice exit from the PolyVault and remove funds from any interest bearing protocols
     * @param _vaultRegistry the address of the registry that the PolyVault will get information from
     * @param _USD the IERC20 interface of the stablecoin being used
     * @param _system the address of the factory that will receive a portion of the interest generated by the funds
     * @dev only callable from the launch contract
     */
    function _exitFromVault(
        address _vaultRegistry,
        IERC20 _USD,
        address _system
    ) external onlySelf {
        require(activated, "PolyVault: Your funds are not currently staked");
        IPolyVaultRegistry.Vault memory selectedVault =
            IPolyVaultRegistry(_vaultRegistry).getRegisteredVault(selectedVaultId);

        if (selectedVault.vaultProvider == 1) {
            ICErc20 compoundContract =
                ICErc20(selectedVault.vaultContractAddress);
            uint256 compoundBalance = compoundContract.balanceOf(address(this));
            compoundContract.redeem(compoundBalance);
        }
        if (selectedVault.vaultProvider == 2) {
            uint256 sharePrice =
                IVault(selectedVault.vaultContractAddress).pricePerShare();
            uint256 redeemResult =
                IVault(selectedVault.vaultContractAddress).withdraw();
        }
        if (selectedVault.vaultProvider == 3) {
            ILendingPool(selectedVault.vaultContractAddress).withdraw(address(_USD), type(uint256).max, address(this));
        }
        uint256 newBalance = _USD.balanceOf(address(this));
        activated = false;
        selectedVaultId = 0;
        selectedVaultProvider = 0;
        if (newBalance > remainingBalance) {
            uint256 excess = (newBalance.sub(remainingBalance)).div(PolylaunchConstants.getExcess());
            _USD.safeTransfer(_system, excess);
        }
        LaunchLogger(_system).logVaultExited(
            address(this)
        );
    }

    /**
     * @notice function to allow a launcher to tap their funds from the vault
     * @param _vaultRegistry the address of the registry that the PolyVault will get information from
     * @param _usdTapRate the wei/sec value that will be used to calculate the tappable funds.
     * @param _USD the IERC20 interface of the stablecoin being used
     * @param _fundRecipient the address to send the tapped funds to
     * @dev only callable from the launch contract
     */
    function _launcherYieldTap(
        address _vaultRegistry,
        uint256 _usdTapRate,
        IERC20 _USD,
        address _fundRecipient,
        address _system
    ) external onlySelf {
        IPolyVaultRegistry.Vault memory selectedVault =
            IPolyVaultRegistry(_vaultRegistry).getRegisteredVault(selectedVaultId);
        if (selectedVaultProvider == 1) {
            _tapCompound(selectedVault, _usdTapRate, _USD, _fundRecipient, _system);
        } else if (selectedVaultProvider == 2) {
            _tapYearn(selectedVault, _usdTapRate, _USD, _fundRecipient, _system);
        } else if (selectedVaultProvider == 3) {
            _tapAave(selectedVault, _usdTapRate, _USD, _fundRecipient, _system);
        }
    }

    ///
    /// COMPOUND FUNCTIONS
    ///

    /**
     * @notice function to allow PolyVault to deposit funds to Compound protocol
     * @param _USD the IERC20 interface of the stablecoin being used
     * @param _usdBalance the amount of _USD to deposit
     * @param _vault struct containing the vault data for a vault id, pulled from VaultRegistry
     * @dev only callable from the PolyVault
     */
    function _activateCompound(
        IERC20 _USD,
        uint256 _usdBalance,
        IPolyVaultRegistry.Vault memory _vault
    ) internal {
        require(
            !activated,
            "PolyVault: Your funds are already in a Compound pool"
        );
        // Approve transfer on the ERC20 contract
        _USD.approve(_vault.vaultContractAddress, _usdBalance);
        activated = true;
        // Mint cTokens
        uint256 mintResult =
            ICErc20(_vault.vaultContractAddress).mint(_usdBalance);
        require(mintResult == 0, "mintResult error");
    }

    /**
     * @notice function to allow PolyVault to tap the funds for the launcher from the Compound Protocol.
     * @param _vault struct containing the vault data for a vault id, pulled from VaultRegistry
     * @param _usdTapRate the wei/sec value associated with the launch to be used to calculate the tappable balance
     * @param _USD the IERC20 interface of the stablecoin being used
     * @param _fundRecipient the address where the tapped funds should be sent to
     * @dev only callable from the PolyVault
     */
    function _tapCompound(
        IPolyVaultRegistry.Vault memory _vault,
        uint256 _usdTapRate,
        IERC20 _USD,
        address _fundRecipient,
        address _system
    ) internal {
        require(activated, "PolyVault: Yield has not been activated");
        uint256 withdrawable =
            _usdTapRate.mul(block.timestamp.sub(lastWithdrawn));
        if (remainingBalance < withdrawable) {
            withdrawable = remainingBalance;
        }
        remainingBalance = remainingBalance.sub(withdrawable);
        lastWithdrawn = block.timestamp;

        // Retrieve your asset based on an amount of the asset
        uint256 redeemResult =
            ICErc20(_vault.vaultContractAddress).redeemUnderlying(withdrawable);
        require(redeemResult == 0, "redeemResult error");
        _USD.safeTransfer(_fundRecipient, withdrawable);
        LaunchLogger(_system).logVaultFundsTapped(
            address(this),
            withdrawable
        );
    }

    ///
    /// YEARN V2 FUNCTIONS
    ///

    /**
     * @notice function to allow PolyVault to deposit funds to Yearn Vaults v2
     * @param _USD the IERC20 interface of the stablecoin being used
     * @param _usdBalance the amount of _USD to deposit
     * @param _vault struct containing the vault data for a vault id, pulled from VaultRegistry
     * @dev only callable from the PolyVault
     */
    function _activateYearnVault(
        IERC20 _USD,
        uint256 _usdBalance,
        IPolyVaultRegistry.Vault memory _vault
    ) internal {
        require(
            !activated,
            "PolyVault: Your funds are already in a Yearn vault"
        );
        // Approve transfer on the ERC20 contract
        _USD.approve(_vault.vaultContractAddress, _usdBalance);
        activated = true;
        // Deposit to yVault v2
        IVault(_vault.vaultContractAddress).deposit(_usdBalance);
    }

    /**
     * @notice function to allow PolyVault to tap the funds for the launcher from Yearn Vaults v2.
     * @param _vault struct containing the vault data for a vault id, pulled from VaultRegistry
     * @param _usdTapRate the wei/sec value associated with the launch to be used to calculate the tappable balance
     * @param _USD the IERC20 interface of the stablecoin being used
     * @param _fundRecipient the address where the tapped funds should be sent to
     * @dev only callable from the PolyVault, rounding errors exist during the share price calculation
     */
    function _tapYearn(
        IPolyVaultRegistry.Vault memory _vault,
        uint256 _usdTapRate,
        IERC20 _USD,
        address _fundRecipient,
        address _system
    ) internal {
        require(activated, "PolyVault: Yield has not been activated");
        uint256 withdrawable =
            _usdTapRate.mul(block.timestamp.sub(lastWithdrawn));
        if (remainingBalance < withdrawable) {
            withdrawable = remainingBalance;
        }
        uint256 sharePrice =
            IVault(_vault.vaultContractAddress).pricePerShare();
        uint256 withdrawableShares = (withdrawable.mul(1e18)).div(sharePrice);
        lastWithdrawn = block.timestamp;
        // Retrieve your asset based on the amount of shares
        uint256 redeemed =
            IVault(_vault.vaultContractAddress).withdraw(withdrawableShares);
        remainingBalance = remainingBalance.sub(withdrawable);
        _USD.safeTransfer(_fundRecipient, redeemed);
        LaunchLogger(_system).logVaultFundsTapped(
            address(this),
            redeemed
        );
    }

    ///
    /// AAVE FUNCTIONS
    ///

    /**
     * @notice function to allow PolyVault to deposit funds to AAVE Lending pools
     * @param _USD the IERC20 interface of the stablecoin being used
     * @param _usdBalance the amount of _USD to deposit
     * @param _vault struct containing the vault data for a vault id, pulled from VaultRegistry
     * @dev only callable from the PolyVault
     */
    function _activateAave(
        IERC20 _USD,
        uint256 _usdBalance,
        IPolyVaultRegistry.Vault memory _vault
    ) internal {
        require(
            !activated,
            "PolyVault: Your funds are already in an Aave pool"
        );
        // Approve transfer on the ERC20 contract
        _USD.approve(_vault.vaultContractAddress, _usdBalance);
        activated = true;
        // Mint Aave
        ILendingPool(_vault.vaultContractAddress).deposit(address(_USD), _usdBalance, address(this), 0);
    }

    /**
     * @notice function to allow PolyVault to tap the funds for the launcher from the Aave Protocol.
     * @param _vault struct containing the vault data for a vault id, pulled from VaultRegistry
     * @param _usdTapRate the wei/sec value associated with the launch to be used to calculate the tappable balance
     * @param _USD the IERC20 interface of the stablecoin being used
     * @param _fundRecipient the address where the tapped funds should be sent to
     * @dev only callable from the PolyVault
     */
    function _tapAave(
        IPolyVaultRegistry.Vault memory _vault,
        uint256 _usdTapRate,
        IERC20 _USD,
        address _fundRecipient,
        address _system
    ) internal {
        require(activated, "PolyVault: Yield has not been activated");
        uint256 withdrawable =
            _usdTapRate.mul(block.timestamp.sub(lastWithdrawn));
        if (remainingBalance < withdrawable) {
            withdrawable = remainingBalance;
        }
        remainingBalance = remainingBalance.sub(withdrawable);
        lastWithdrawn = block.timestamp;

        // Retrieve your asset based on an amount of the asset
        ILendingPool(_vault.vaultContractAddress).withdraw(address(_USD), withdrawable, _fundRecipient);
        LaunchLogger(_system).logVaultFundsTapped(
            address(this),
            withdrawable
        );
    }
}
